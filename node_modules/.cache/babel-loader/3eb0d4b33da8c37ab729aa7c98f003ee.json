{"ast":null,"code":"var Libpq = require('libpq');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar assert = require('assert');\n\nvar types = require('pg-types');\n\nvar buildResult = require('./lib/build-result');\n\nvar CopyStream = require('./lib/copy-stream');\n\nvar Client = module.exports = function (config) {\n  if (!(this instanceof Client)) {\n    return new Client(config);\n  }\n\n  config = config || {};\n  EventEmitter.call(this);\n  this.pq = new Libpq();\n  this._reading = false;\n  this._read = this._read.bind(this); // allow custom type converstion to be passed in\n\n  this._types = config.types || types; // allow config to specify returning results\n  // as an array of values instead of a hash\n\n  this.arrayMode = config.arrayMode || false;\n  this._resultCount = 0;\n  this._rows = undefined;\n  this._results = undefined; // lazy start the reader if notifications are listened for\n  // this way if you only run sync queries you wont block\n  // the event loop artificially\n\n  this.on('newListener', event => {\n    if (event !== 'notification') return;\n\n    this._startReading();\n  });\n  this.on('result', this._onResult.bind(this));\n  this.on('readyForQuery', this._onReadyForQuery.bind(this));\n};\n\nutil.inherits(Client, EventEmitter);\n\nClient.prototype.connect = function (params, cb) {\n  this.pq.connect(params, cb);\n};\n\nClient.prototype.connectSync = function (params) {\n  this.pq.connectSync(params);\n};\n\nClient.prototype.query = function (text, values, cb) {\n  var queryFn;\n\n  if (typeof values === 'function') {\n    cb = values;\n\n    queryFn = function () {\n      return self.pq.sendQuery(text);\n    };\n  } else {\n    queryFn = function () {\n      return self.pq.sendQueryParams(text, values);\n    };\n  }\n\n  var self = this;\n\n  self._dispatchQuery(self.pq, queryFn, function (err) {\n    if (err) return cb(err);\n\n    self._awaitResult(cb);\n  });\n};\n\nClient.prototype.prepare = function (statementName, text, nParams, cb) {\n  var self = this;\n\n  var fn = function () {\n    return self.pq.sendPrepare(statementName, text, nParams);\n  };\n\n  self._dispatchQuery(self.pq, fn, function (err) {\n    if (err) return cb(err);\n\n    self._awaitResult(cb);\n  });\n};\n\nClient.prototype.execute = function (statementName, parameters, cb) {\n  var self = this;\n\n  var fn = function () {\n    return self.pq.sendQueryPrepared(statementName, parameters);\n  };\n\n  self._dispatchQuery(self.pq, fn, function (err, rows) {\n    if (err) return cb(err);\n\n    self._awaitResult(cb);\n  });\n};\n\nClient.prototype.getCopyStream = function () {\n  this.pq.setNonBlocking(true);\n\n  this._stopReading();\n\n  return new CopyStream(this.pq);\n}; // cancel a currently executing query\n\n\nClient.prototype.cancel = function (cb) {\n  assert(cb, 'Callback is required'); // result is either true or a string containing an error\n\n  var result = this.pq.cancel();\n  return setImmediate(function () {\n    cb(result === true ? undefined : new Error(result));\n  });\n};\n\nClient.prototype.querySync = function (text, values) {\n  if (values) {\n    this.pq.execParams(text, values);\n  } else {\n    this.pq.exec(text);\n  }\n\n  throwIfError(this.pq);\n  const result = buildResult(this.pq, this._types, this.arrayMode);\n  return result.rows;\n};\n\nClient.prototype.prepareSync = function (statementName, text, nParams) {\n  this.pq.prepare(statementName, text, nParams);\n  throwIfError(this.pq);\n};\n\nClient.prototype.executeSync = function (statementName, parameters) {\n  this.pq.execPrepared(statementName, parameters);\n  throwIfError(this.pq);\n  return buildResult(this.pq, this._types, this.arrayMode).rows;\n};\n\nClient.prototype.escapeLiteral = function (value) {\n  return this.pq.escapeLiteral(value);\n};\n\nClient.prototype.escapeIdentifier = function (value) {\n  return this.pq.escapeIdentifier(value);\n}; // export the version number so we can check it in node-postgres\n\n\nmodule.exports.version = require('./package.json').version;\n\nClient.prototype.end = function (cb) {\n  this._stopReading();\n\n  this.pq.finish();\n  if (cb) setImmediate(cb);\n};\n\nClient.prototype._readError = function (message) {\n  var err = new Error(message || this.pq.errorMessage());\n  this.emit('error', err);\n};\n\nClient.prototype._stopReading = function () {\n  if (!this._reading) return;\n  this._reading = false;\n  this.pq.stopReader();\n  this.pq.removeListener('readable', this._read);\n};\n\nClient.prototype._consumeQueryResults = function (pq) {\n  return buildResult(pq, this._types, this.arrayMode);\n};\n\nClient.prototype._emitResult = function (pq) {\n  var status = pq.resultStatus();\n\n  switch (status) {\n    case 'PGRES_FATAL_ERROR':\n      this._queryError = new Error(this.pq.resultErrorMessage());\n      break;\n\n    case 'PGRES_TUPLES_OK':\n    case 'PGRES_COMMAND_OK':\n    case 'PGRES_EMPTY_QUERY':\n      const result = this._consumeQueryResults(this.pq);\n\n      this.emit('result', result);\n      break;\n\n    case 'PGRES_COPY_OUT':\n    case 'PGRES_COPY_BOTH':\n      {\n        break;\n      }\n\n    default:\n      this._readError('unrecognized command status: ' + status);\n\n      break;\n  }\n\n  return status;\n}; // called when libpq is readable\n\n\nClient.prototype._read = function () {\n  var pq = this.pq; // read waiting data from the socket\n  // e.g. clear the pending 'select'\n\n  if (!pq.consumeInput()) {\n    // if consumeInput returns false\n    // than a read error has been encountered\n    return this._readError();\n  } // check if there is still outstanding data\n  // if so, wait for it all to come in\n\n\n  if (pq.isBusy()) {\n    return;\n  } // load our result object\n\n\n  while (pq.getResult()) {\n    const resultStatus = this._emitResult(this.pq); // if the command initiated copy mode we need to break out of the read loop\n    // so a substream can begin to read copy data\n\n\n    if (resultStatus === 'PGRES_COPY_BOTH' || resultStatus === 'PGRES_COPY_OUT') {\n      break;\n    } // if reading multiple results, sometimes the following results might cause\n    // a blocking read. in this scenario yield back off the reader until libpq is readable\n\n\n    if (pq.isBusy()) {\n      return;\n    }\n  }\n\n  this.emit('readyForQuery');\n  var notice = this.pq.notifies();\n\n  while (notice) {\n    this.emit('notification', notice);\n    notice = this.pq.notifies();\n  }\n}; // ensures the client is reading and\n// everything is set up for async io\n\n\nClient.prototype._startReading = function () {\n  if (this._reading) return;\n  this._reading = true;\n  this.pq.on('readable', this._read);\n  this.pq.startReader();\n};\n\nvar throwIfError = function (pq) {\n  var err = pq.resultErrorMessage() || pq.errorMessage();\n\n  if (err) {\n    throw new Error(err);\n  }\n};\n\nClient.prototype._awaitResult = function (cb) {\n  this._queryCallback = cb;\n  return this._startReading();\n}; // wait for the writable socket to drain\n\n\nClient.prototype._waitForDrain = function (pq, cb) {\n  var res = pq.flush(); // res of 0 is success\n\n  if (res === 0) return cb(); // res of -1 is failure\n\n  if (res === -1) return cb(pq.errorMessage()); // otherwise outgoing message didn't flush to socket\n  // wait for it to flush and try again\n\n  var self = this; // you cannot read & write on a socket at the same time\n\n  return pq.writable(function () {\n    self._waitForDrain(pq, cb);\n  });\n}; // send an async query to libpq and wait for it to\n// finish writing query text to the socket\n\n\nClient.prototype._dispatchQuery = function (pq, fn, cb) {\n  this._stopReading();\n\n  var success = pq.setNonBlocking(true);\n  if (!success) return cb(new Error('Unable to set non-blocking to true'));\n  var sent = fn();\n  if (!sent) return cb(new Error(pq.errorMessage() || 'Something went wrong dispatching the query'));\n\n  this._waitForDrain(pq, cb);\n};\n\nClient.prototype._onResult = function (result) {\n  if (this._resultCount === 0) {\n    this._results = result;\n    this._rows = result.rows;\n  } else if (this._resultCount === 1) {\n    this._results = [this._results, result];\n    this._rows = [this._rows, result.rows];\n  } else {\n    this._results.push(result);\n\n    this._rows.push(result.rows);\n  }\n\n  this._resultCount++;\n};\n\nClient.prototype._onReadyForQuery = function () {\n  // remove instance callback\n  const cb = this._queryCallback;\n  this._queryCallback = undefined; // remove instance query error\n\n  const err = this._queryError;\n  this._queryError = undefined; // remove instance rows\n\n  const rows = this._rows;\n  this._rows = undefined; // remove instance results\n\n  const results = this._results;\n  this._results = undefined;\n  this._resultCount = 0;\n\n  if (cb) {\n    cb(err, rows || [], results);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}