{"ast":null,"code":"'use strict';\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar Result = require('./result');\n\nvar utils = require('./utils');\n\nvar Query = function (config, values, callback) {\n  // use of \"new\" optional\n  if (!(this instanceof Query)) {\n    return new Query(config, values, callback);\n  }\n\n  config = utils.normalizeQueryConfig(config, values, callback);\n  this.text = config.text;\n  this.values = config.values;\n  this.rows = config.rows;\n  this.types = config.types;\n  this.name = config.name;\n  this.binary = config.binary; // use unique portal name each time\n\n  this.portal = config.portal || '';\n  this.callback = config.callback;\n  this._rowMode = config.rowMode;\n\n  if (process.domain && config.callback) {\n    this.callback = process.domain.bind(config.callback);\n  }\n\n  this._result = new Result(this._rowMode, this.types); // potential for multiple results\n\n  this._results = this._result;\n  this.isPreparedStatement = false;\n  this._canceledDueToError = false;\n  this._promise = null;\n  EventEmitter.call(this);\n};\n\nutil.inherits(Query, EventEmitter);\n\nQuery.prototype.requiresPreparation = function () {\n  // named queries must always be prepared\n  if (this.name) {\n    return true;\n  } // always prepare if there are max number of rows expected per\n  // portal execution\n\n\n  if (this.rows) {\n    return true;\n  } // don't prepare empty text queries\n\n\n  if (!this.text) {\n    return false;\n  } // prepare if there are values\n\n\n  if (!this.values) {\n    return false;\n  }\n\n  return this.values.length > 0;\n};\n\nQuery.prototype._checkForMultirow = function () {\n  // if we already have a result with a command property\n  // then we've already executed one query in a multi-statement simple query\n  // turn our results into an array of results\n  if (this._result.command) {\n    if (!Array.isArray(this._results)) {\n      this._results = [this._result];\n    }\n\n    this._result = new Result(this._rowMode, this.types);\n\n    this._results.push(this._result);\n  }\n}; // associates row metadata from the supplied\n// message with this query object\n// metadata used when parsing row results\n\n\nQuery.prototype.handleRowDescription = function (msg) {\n  this._checkForMultirow();\n\n  this._result.addFields(msg.fields);\n\n  this._accumulateRows = this.callback || !this.listeners('row').length;\n};\n\nQuery.prototype.handleDataRow = function (msg) {\n  var row;\n\n  if (this._canceledDueToError) {\n    return;\n  }\n\n  try {\n    row = this._result.parseRow(msg.fields);\n  } catch (err) {\n    this._canceledDueToError = err;\n    return;\n  }\n\n  this.emit('row', row, this._result);\n\n  if (this._accumulateRows) {\n    this._result.addRow(row);\n  }\n};\n\nQuery.prototype.handleCommandComplete = function (msg, con) {\n  this._checkForMultirow();\n\n  this._result.addCommandComplete(msg); // need to sync after each command complete of a prepared statement\n\n\n  if (this.isPreparedStatement) {\n    con.sync();\n  }\n}; // if a named prepared statement is created with empty query text\n// the backend will send an emptyQuery message but *not* a command complete message\n// execution on the connection will hang until the backend receives a sync message\n\n\nQuery.prototype.handleEmptyQuery = function (con) {\n  if (this.isPreparedStatement) {\n    con.sync();\n  }\n};\n\nQuery.prototype.handleReadyForQuery = function (con) {\n  if (this._canceledDueToError) {\n    return this.handleError(this._canceledDueToError, con);\n  }\n\n  if (this.callback) {\n    this.callback(null, this._results);\n  }\n\n  this.emit('end', this._results);\n};\n\nQuery.prototype.handleError = function (err, connection) {\n  // need to sync after error during a prepared statement\n  if (this.isPreparedStatement) {\n    connection.sync();\n  }\n\n  if (this._canceledDueToError) {\n    err = this._canceledDueToError;\n    this._canceledDueToError = false;\n  } // if callback supplied do not emit error event as uncaught error\n  // events will bubble up to node process\n\n\n  if (this.callback) {\n    return this.callback(err);\n  }\n\n  this.emit('error', err);\n};\n\nQuery.prototype.submit = function (connection) {\n  if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n    return new Error('A query must have either text or a name. Supplying neither is unsupported.');\n  }\n\n  const previous = connection.parsedStatements[this.name];\n\n  if (this.text && previous && this.text !== previous) {\n    return new Error(\"Prepared statements must be unique - '\".concat(this.name, \"' was used for a different statement\"));\n  }\n\n  if (this.values && !Array.isArray(this.values)) {\n    return new Error('Query values must be an array');\n  }\n\n  if (this.requiresPreparation()) {\n    this.prepare(connection);\n  } else {\n    connection.query(this.text);\n  }\n\n  return null;\n};\n\nQuery.prototype.hasBeenParsed = function (connection) {\n  return this.name && connection.parsedStatements[this.name];\n};\n\nQuery.prototype.handlePortalSuspended = function (connection) {\n  this._getRows(connection, this.rows);\n};\n\nQuery.prototype._getRows = function (connection, rows) {\n  connection.execute({\n    portal: this.portal,\n    rows: rows\n  }, true);\n  connection.flush();\n};\n\nQuery.prototype.prepare = function (connection) {\n  var self = this; // prepared statements need sync to be called after each command\n  // complete or when an error is encountered\n\n  this.isPreparedStatement = true; // TODO refactor this poor encapsulation\n\n  if (!this.hasBeenParsed(connection)) {\n    connection.parse({\n      text: self.text,\n      name: self.name,\n      types: self.types\n    }, true);\n  }\n\n  if (self.values) {\n    try {\n      self.values = self.values.map(utils.prepareValue);\n    } catch (err) {\n      this.handleError(err, connection);\n      return;\n    }\n  } // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n\n\n  connection.bind({\n    portal: self.portal,\n    statement: self.name,\n    values: self.values,\n    binary: self.binary\n  }, true);\n  connection.describe({\n    type: 'P',\n    name: self.portal || ''\n  }, true);\n\n  this._getRows(connection, this.rows);\n};\n\nQuery.prototype.handleCopyInResponse = function (connection) {\n  connection.sendCopyFail('No source stream defined');\n};\n\nQuery.prototype.handleCopyData = function (msg, connection) {// noop\n};\n\nmodule.exports = Query;","map":null,"metadata":{},"sourceType":"script"}