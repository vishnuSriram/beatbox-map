{"ast":null,"code":"'use strict';\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar sasl = require('./sasl');\n\nvar pgPass = require('pgpass');\n\nvar TypeOverrides = require('./type-overrides');\n\nvar ConnectionParameters = require('./connection-parameters');\n\nvar Query = require('./query');\n\nvar defaults = require('./defaults');\n\nvar Connection = require('./connection');\n\nvar Client = function (config) {\n  EventEmitter.call(this);\n  this.connectionParameters = new ConnectionParameters(config);\n  this.user = this.connectionParameters.user;\n  this.database = this.connectionParameters.database;\n  this.port = this.connectionParameters.port;\n  this.host = this.connectionParameters.host;\n  this.password = this.connectionParameters.password;\n  this.replication = this.connectionParameters.replication;\n  var c = config || {};\n  this._Promise = c.Promise || global.Promise;\n  this._types = new TypeOverrides(c.types);\n  this._ending = false;\n  this._connecting = false;\n  this._connected = false;\n  this._connectionError = false;\n  this._queryable = true;\n  this.connection = c.connection || new Connection({\n    stream: c.stream,\n    ssl: this.connectionParameters.ssl,\n    keepAlive: c.keepAlive || false,\n    keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n    encoding: this.connectionParameters.client_encoding || 'utf8'\n  });\n  this.queryQueue = [];\n  this.binary = c.binary || defaults.binary;\n  this.processID = null;\n  this.secretKey = null;\n  this.ssl = this.connectionParameters.ssl || false;\n  this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;\n};\n\nutil.inherits(Client, EventEmitter);\n\nClient.prototype._errorAllQueries = function (err) {\n  const enqueueError = query => {\n    process.nextTick(() => {\n      query.handleError(err, this.connection);\n    });\n  };\n\n  if (this.activeQuery) {\n    enqueueError(this.activeQuery);\n    this.activeQuery = null;\n  }\n\n  this.queryQueue.forEach(enqueueError);\n  this.queryQueue.length = 0;\n};\n\nClient.prototype._connect = function (callback) {\n  var self = this;\n  var con = this.connection;\n\n  if (this._connecting || this._connected) {\n    const err = new Error('Client has already been connected. You cannot reuse a client.');\n    process.nextTick(() => {\n      callback(err);\n    });\n    return;\n  }\n\n  this._connecting = true;\n  var connectionTimeoutHandle;\n\n  if (this._connectionTimeoutMillis > 0) {\n    connectionTimeoutHandle = setTimeout(() => {\n      con._ending = true;\n      con.stream.destroy(new Error('timeout expired'));\n    }, this._connectionTimeoutMillis);\n  }\n\n  if (this.host && this.host.indexOf('/') === 0) {\n    con.connect(this.host + '/.s.PGSQL.' + this.port);\n  } else {\n    con.connect(this.port, this.host);\n  } // once connection is established send startup message\n\n\n  con.on('connect', function () {\n    if (self.ssl) {\n      con.requestSsl();\n    } else {\n      con.startup(self.getStartupConf());\n    }\n  });\n  con.on('sslconnect', function () {\n    con.startup(self.getStartupConf());\n  });\n\n  function checkPgPass(cb) {\n    return function (msg) {\n      if (self.password !== null) {\n        cb(msg);\n      } else {\n        pgPass(self.connectionParameters, function (pass) {\n          if (undefined !== pass) {\n            self.connectionParameters.password = self.password = pass;\n          }\n\n          cb(msg);\n        });\n      }\n    };\n  } // password request handling\n\n\n  con.on('authenticationCleartextPassword', checkPgPass(function () {\n    con.password(self.password);\n  })); // password request handling\n\n  con.on('authenticationMD5Password', checkPgPass(function (msg) {\n    con.password(utils.postgresMd5PasswordHash(self.user, self.password, msg.salt));\n  })); // password request handling (SASL)\n\n  var saslSession;\n  con.on('authenticationSASL', checkPgPass(function (msg) {\n    saslSession = sasl.startSession(msg.mechanisms);\n    con.sendSASLInitialResponseMessage(saslSession.mechanism, saslSession.response);\n  })); // password request handling (SASL)\n\n  con.on('authenticationSASLContinue', function (msg) {\n    sasl.continueSession(saslSession, self.password, msg.data);\n    con.sendSCRAMClientFinalMessage(saslSession.response);\n  }); // password request handling (SASL)\n\n  con.on('authenticationSASLFinal', function (msg) {\n    sasl.finalizeSession(saslSession, msg.data);\n    saslSession = null;\n  });\n  con.once('backendKeyData', function (msg) {\n    self.processID = msg.processID;\n    self.secretKey = msg.secretKey;\n  });\n\n  const connectingErrorHandler = err => {\n    if (this._connectionError) {\n      return;\n    }\n\n    this._connectionError = true;\n    clearTimeout(connectionTimeoutHandle);\n\n    if (callback) {\n      return callback(err);\n    }\n\n    this.emit('error', err);\n  };\n\n  const connectedErrorHandler = err => {\n    this._queryable = false;\n\n    this._errorAllQueries(err);\n\n    this.emit('error', err);\n  };\n\n  const connectedErrorMessageHandler = msg => {\n    const activeQuery = this.activeQuery;\n\n    if (!activeQuery) {\n      connectedErrorHandler(msg);\n      return;\n    }\n\n    this.activeQuery = null;\n    activeQuery.handleError(msg, con);\n  };\n\n  con.on('error', connectingErrorHandler);\n  con.on('errorMessage', connectingErrorHandler); // hook up query handling events to connection\n  // after the connection initially becomes ready for queries\n\n  con.once('readyForQuery', function () {\n    self._connecting = false;\n    self._connected = true;\n\n    self._attachListeners(con);\n\n    con.removeListener('error', connectingErrorHandler);\n    con.removeListener('errorMessage', connectingErrorHandler);\n    con.on('error', connectedErrorHandler);\n    con.on('errorMessage', connectedErrorMessageHandler);\n    clearTimeout(connectionTimeoutHandle); // process possible callback argument to Client#connect\n\n    if (callback) {\n      callback(null, self); // remove callback for proper error handling\n      // after the connect event\n\n      callback = null;\n    }\n\n    self.emit('connect');\n  });\n  con.on('readyForQuery', function () {\n    var activeQuery = self.activeQuery;\n    self.activeQuery = null;\n    self.readyForQuery = true;\n\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(con);\n    }\n\n    self._pulseQueryQueue();\n  });\n  con.once('end', () => {\n    const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly');\n\n    this._errorAllQueries(error);\n\n    if (!this._ending) {\n      // if the connection is ended without us calling .end()\n      // on this client then we have an unexpected disconnection\n      // treat this as an error unless we've already emitted an error\n      // during connection.\n      if (this._connecting && !this._connectionError) {\n        if (callback) {\n          callback(error);\n        } else {\n          connectedErrorHandler(error);\n        }\n      } else if (!this._connectionError) {\n        connectedErrorHandler(error);\n      }\n    }\n\n    process.nextTick(() => {\n      this.emit('end');\n    });\n  });\n  con.on('notice', function (msg) {\n    self.emit('notice', msg);\n  });\n};\n\nClient.prototype.connect = function (callback) {\n  if (callback) {\n    this._connect(callback);\n\n    return;\n  }\n\n  return new this._Promise((resolve, reject) => {\n    this._connect(error => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve();\n      }\n    });\n  });\n};\n\nClient.prototype._attachListeners = function (con) {\n  const self = this; // delegate rowDescription to active query\n\n  con.on('rowDescription', function (msg) {\n    self.activeQuery.handleRowDescription(msg);\n  }); // delegate dataRow to active query\n\n  con.on('dataRow', function (msg) {\n    self.activeQuery.handleDataRow(msg);\n  }); // delegate portalSuspended to active query\n\n  con.on('portalSuspended', function (msg) {\n    self.activeQuery.handlePortalSuspended(con);\n  }); // deletagate emptyQuery to active query\n\n  con.on('emptyQuery', function (msg) {\n    self.activeQuery.handleEmptyQuery(con);\n  }); // delegate commandComplete to active query\n\n  con.on('commandComplete', function (msg) {\n    self.activeQuery.handleCommandComplete(msg, con);\n  }); // if a prepared statement has a name and properly parses\n  // we track that its already been executed so we don't parse\n  // it again on the same client\n\n  con.on('parseComplete', function (msg) {\n    if (self.activeQuery.name) {\n      con.parsedStatements[self.activeQuery.name] = self.activeQuery.text;\n    }\n  });\n  con.on('copyInResponse', function (msg) {\n    self.activeQuery.handleCopyInResponse(self.connection);\n  });\n  con.on('copyData', function (msg) {\n    self.activeQuery.handleCopyData(msg, self.connection);\n  });\n  con.on('notification', function (msg) {\n    self.emit('notification', msg);\n  });\n};\n\nClient.prototype.getStartupConf = function () {\n  var params = this.connectionParameters;\n  var data = {\n    user: params.user,\n    database: params.database\n  };\n  var appName = params.application_name || params.fallback_application_name;\n\n  if (appName) {\n    data.application_name = appName;\n  }\n\n  if (params.replication) {\n    data.replication = '' + params.replication;\n  }\n\n  if (params.statement_timeout) {\n    data.statement_timeout = String(parseInt(params.statement_timeout, 10));\n  }\n\n  return data;\n};\n\nClient.prototype.cancel = function (client, query) {\n  if (client.activeQuery === query) {\n    var con = this.connection;\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port);\n    } else {\n      con.connect(this.port, this.host);\n    } // once connection is established send cancel message\n\n\n    con.on('connect', function () {\n      con.cancel(client.processID, client.secretKey);\n    });\n  } else if (client.queryQueue.indexOf(query) !== -1) {\n    client.queryQueue.splice(client.queryQueue.indexOf(query), 1);\n  }\n};\n\nClient.prototype.setTypeParser = function (oid, format, parseFn) {\n  return this._types.setTypeParser(oid, format, parseFn);\n};\n\nClient.prototype.getTypeParser = function (oid, format) {\n  return this._types.getTypeParser(oid, format);\n}; // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n\nClient.prototype.escapeIdentifier = function (str) {\n  return '\"' + str.replace(/\"/g, '\"\"') + '\"';\n}; // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n\nClient.prototype.escapeLiteral = function (str) {\n  var hasBackslash = false;\n  var escaped = '\\'';\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str[i];\n\n    if (c === '\\'') {\n      escaped += c + c;\n    } else if (c === '\\\\') {\n      escaped += c + c;\n      hasBackslash = true;\n    } else {\n      escaped += c;\n    }\n  }\n\n  escaped += '\\'';\n\n  if (hasBackslash === true) {\n    escaped = ' E' + escaped;\n  }\n\n  return escaped;\n};\n\nClient.prototype._pulseQueryQueue = function () {\n  if (this.readyForQuery === true) {\n    this.activeQuery = this.queryQueue.shift();\n\n    if (this.activeQuery) {\n      this.readyForQuery = false;\n      this.hasExecuted = true;\n      const queryError = this.activeQuery.submit(this.connection);\n\n      if (queryError) {\n        process.nextTick(() => {\n          this.activeQuery.handleError(queryError, this.connection);\n          this.readyForQuery = true;\n\n          this._pulseQueryQueue();\n        });\n      }\n    } else if (this.hasExecuted) {\n      this.activeQuery = null;\n      this.emit('drain');\n    }\n  }\n};\n\nClient.prototype.query = function (config, values, callback) {\n  // can take in strings, config object or query object\n  var query;\n  var result;\n  var readTimeout;\n  var readTimeoutTimer;\n  var queryCallback;\n\n  if (config === null || config === undefined) {\n    throw new TypeError('Client was passed a null or undefined query');\n  } else if (typeof config.submit === 'function') {\n    readTimeout = config.query_timeout || this.connectionParameters.query_timeout;\n    result = query = config;\n\n    if (typeof values === 'function') {\n      query.callback = query.callback || values;\n    }\n  } else {\n    readTimeout = this.connectionParameters.query_timeout;\n    query = new Query(config, values, callback);\n\n    if (!query.callback) {\n      result = new this._Promise((resolve, reject) => {\n        query.callback = (err, res) => err ? reject(err) : resolve(res);\n      });\n    }\n  }\n\n  if (readTimeout) {\n    queryCallback = query.callback;\n    readTimeoutTimer = setTimeout(() => {\n      var error = new Error('Query read timeout');\n      process.nextTick(() => {\n        query.handleError(error, this.connection);\n      });\n      queryCallback(error); // we already returned an error,\n      // just do nothing if query completes\n\n      query.callback = () => {}; // Remove from queue\n\n\n      var index = this.queryQueue.indexOf(query);\n\n      if (index > -1) {\n        this.queryQueue.splice(index, 1);\n      }\n\n      this._pulseQueryQueue();\n    }, readTimeout);\n\n    query.callback = (err, res) => {\n      clearTimeout(readTimeoutTimer);\n      queryCallback(err, res);\n    };\n  }\n\n  if (this.binary && !query.binary) {\n    query.binary = true;\n  }\n\n  if (query._result && !query._result._types) {\n    query._result._types = this._types;\n  }\n\n  if (!this._queryable) {\n    process.nextTick(() => {\n      query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection);\n    });\n    return result;\n  }\n\n  if (this._ending) {\n    process.nextTick(() => {\n      query.handleError(new Error('Client was closed and is not queryable'), this.connection);\n    });\n    return result;\n  }\n\n  this.queryQueue.push(query);\n\n  this._pulseQueryQueue();\n\n  return result;\n};\n\nClient.prototype.end = function (cb) {\n  this._ending = true;\n\n  if (this.activeQuery) {\n    // if we have an active query we need to force a disconnect\n    // on the socket - otherwise a hung query could block end forever\n    this.connection.stream.destroy();\n  } else {\n    this.connection.end();\n  }\n\n  if (cb) {\n    this.connection.once('end', cb);\n  } else {\n    return new this._Promise(resolve => {\n      this.connection.once('end', resolve);\n    });\n  }\n}; // expose a Query constructor\n\n\nClient.Query = Query;\nmodule.exports = Client;","map":null,"metadata":{},"sourceType":"script"}