{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst NOOP = function () {};\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate);\n  return i === -1 ? undefined : list.splice(i, 1)[0];\n};\n\nclass IdleItem {\n  constructor(client, timeoutId) {\n    this.client = client;\n    this.timeoutId = timeoutId;\n  }\n\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback;\n  }\n\n}\n\nfunction throwOnRelease() {\n  throw new Error('Release called on client which has already been released to the pool.');\n}\n\nfunction release(client, err) {\n  client.release = throwOnRelease;\n\n  if (err || this.ending) {\n    this._remove(client);\n\n    this._pulseQueue();\n\n    return;\n  } // idle timeout\n\n\n  let tid;\n\n  if (this.options.idleTimeoutMillis) {\n    tid = setTimeout(() => {\n      this.log('remove idle client');\n\n      this._remove(client);\n    }, this.options.idleTimeoutMillis);\n  }\n\n  this._idle.push(new IdleItem(client, tid));\n\n  this._pulseQueue();\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return {\n      callback: callback,\n      result: undefined\n    };\n  }\n\n  let rej;\n  let res;\n\n  const cb = function (err, client) {\n    err ? rej(err) : res(client);\n  };\n\n  const result = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    callback: cb,\n    result: result\n  };\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client;\n    client.removeListener('error', idleListener);\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err);\n    });\n\n    pool._remove(client); // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n\n\n    pool.emit('error', err, client);\n  };\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super();\n    this.options = Object.assign({}, options);\n    this.options.max = this.options.max || this.options.poolSize || 10;\n\n    this.log = this.options.log || function () {};\n\n    this.Client = this.options.Client || Client || require('pg').Client;\n    this.Promise = this.options.Promise || global.Promise;\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000;\n    }\n\n    this._clients = [];\n    this._idle = [];\n    this._pendingQueue = [];\n    this._endCallback = undefined;\n    this.ending = false;\n    this.ended = false;\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max;\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue');\n\n    if (this.ended) {\n      this.log('pulse queue ended');\n      return;\n    }\n\n    if (this.ending) {\n      this.log('pulse queue on ending');\n\n      if (this._idle.length) {\n        this._idle.slice().map(item => {\n          this._remove(item.client);\n        });\n      }\n\n      if (!this._clients.length) {\n        this.ended = true;\n\n        this._endCallback();\n      }\n\n      return;\n    } // if we don't have any waiting, do nothing\n\n\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests');\n      return;\n    } // if we don't have any idle clients and we have no more room do nothing\n\n\n    if (!this._idle.length && this._isFull()) {\n      return;\n    }\n\n    const waiter = this._pendingQueue.shift();\n\n    if (this._idle.length) {\n      const idleItem = this._idle.pop();\n\n      clearTimeout(idleItem.timeoutId);\n      const client = idleItem.client;\n      client.release = release.bind(this, client);\n      this.emit('acquire', client);\n      return waiter.callback(undefined, client, client.release);\n    }\n\n    if (!this._isFull()) {\n      return this.newClient(waiter);\n    }\n\n    throw new Error('unexpected condition');\n  }\n\n  _remove(client) {\n    const removed = removeWhere(this._idle, item => item.client === client);\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId);\n    }\n\n    this._clients = this._clients.filter(c => c !== client);\n    client.end();\n    this.emit('remove', client);\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool');\n      return cb ? cb(err) : this.Promise.reject(err);\n    }\n\n    const response = promisify(this.Promise, cb);\n    const result = response.result; // if we don't have to connect a new client, don't do so\n\n    if (this._clients.length >= this.options.max || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue());\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback));\n\n        return result;\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid);\n        response.callback(err, res, done);\n      };\n\n      const pendingItem = new PendingItem(queueCallback); // set connection timeout on checking out an existing client\n\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, i => i.callback === queueCallback);\n        pendingItem.timedOut = true;\n        response.callback(new Error('timeout exceeded when trying to connect'));\n      }, this.options.connectionTimeoutMillis);\n\n      this._pendingQueue.push(pendingItem);\n\n      return result;\n    }\n\n    this.newClient(new PendingItem(response.callback));\n    return result;\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options);\n\n    this._clients.push(client);\n\n    const idleListener = makeIdleListener(this, client);\n    this.log('checking client timeout'); // connection timeout logic\n\n    let tid;\n    let timeoutHit = false;\n\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout');\n        timeoutHit = true; // force kill the node driver, and let libpq do its teardown\n\n        client.connection ? client.connection.stream.destroy() : client.end();\n      }, this.options.connectionTimeoutMillis);\n    }\n\n    this.log('connecting new client');\n    client.connect(err => {\n      if (tid) {\n        clearTimeout(tid);\n      }\n\n      client.on('error', idleListener);\n\n      if (err) {\n        this.log('client failed to connect', err); // remove the dead client from our list of clients\n\n        this._clients = this._clients.filter(c => c !== client);\n\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout';\n        } // this client wonâ€™t be released, so move on immediately\n\n\n        this._pulseQueue();\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP);\n        }\n      } else {\n        this.log('new client connected');\n        client.release = release.bind(this, client);\n        this.emit('connect', client);\n        this.emit('acquire', client);\n\n        if (!pendingItem.timedOut) {\n          if (this.options.verify) {\n            this.options.verify(client, pendingItem.callback);\n          } else {\n            pendingItem.callback(undefined, client, client.release);\n          }\n        } else {\n          if (this.options.verify) {\n            this.options.verify(client, client.release);\n          } else {\n            client.release();\n          }\n        }\n      }\n    });\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text);\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'));\n      });\n      return response.result;\n    } // allow plain text query without values\n\n\n    if (typeof values === 'function') {\n      cb = values;\n      values = undefined;\n    }\n\n    const response = promisify(this.Promise, cb);\n    cb = response.callback;\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err);\n      }\n\n      this.log('dispatching query');\n      client.query(text, values, (err, res) => {\n        this.log('query dispatched');\n        client.release(err);\n\n        if (err) {\n          return cb(err);\n        } else {\n          return cb(undefined, res);\n        }\n      });\n    });\n    return response.result;\n  }\n\n  end(cb) {\n    this.log('ending');\n\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once');\n      return cb ? cb(err) : this.Promise.reject(err);\n    }\n\n    this.ending = true;\n    const promised = promisify(this.Promise, cb);\n    this._endCallback = promised.callback;\n\n    this._pulseQueue();\n\n    return promised.result;\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length;\n  }\n\n  get idleCount() {\n    return this._idle.length;\n  }\n\n  get totalCount() {\n    return this._clients.length;\n  }\n\n}\n\nmodule.exports = Pool;","map":null,"metadata":{},"sourceType":"script"}