{"ast":null,"code":"var Duplex = require('stream').Duplex;\n\nvar Writable = require('stream').Writable;\n\nvar util = require('util');\n\nvar CopyStream = module.exports = function (pq, options) {\n  Duplex.call(this, options);\n  this.pq = pq;\n  this._reading = false;\n};\n\nutil.inherits(CopyStream, Duplex); // writer methods\n\nCopyStream.prototype._write = function (chunk, encoding, cb) {\n  var result = this.pq.putCopyData(chunk); // sent successfully\n\n  if (result === 1) return cb(); // error\n\n  if (result === -1) return cb(new Error(this.pq.errorMessage())); // command would block. wait for writable and call again.\n\n  var self = this;\n  this.pq.writable(function () {\n    self._write(chunk, encoding, cb);\n  });\n};\n\nCopyStream.prototype.end = function () {\n  var args = Array.prototype.slice.call(arguments, 0);\n  var self = this;\n  var callback = args.pop();\n\n  if (args.length) {\n    this.write(args[0]);\n  }\n\n  var result = this.pq.putCopyEnd(); // sent successfully\n\n  if (result === 1) {\n    // consume our results and then call 'end' on the\n    // \"parent\" writable class so we can emit 'finish' and\n    // all that jazz\n    return consumeResults(this.pq, function (err, res) {\n      Writable.prototype.end.call(self); // handle possible passing of callback to end method\n\n      if (callback) {\n        callback(err);\n      }\n    });\n  } // error\n\n\n  if (result === -1) {\n    var err = new Error(this.pq.errorMessage());\n    return this.emit('error', err);\n  } // command would block. wait for writable and call end again\n  // don't pass any buffers to end on the second call because\n  // we already sent them to possible this.write the first time\n  // we called end\n\n\n  return this.pq.writable(function () {\n    return self.end.apply(self, callback);\n  });\n}; // reader methods\n\n\nCopyStream.prototype._consumeBuffer = function (cb) {\n  var result = this.pq.getCopyData(true);\n\n  if (result instanceof Buffer) {\n    return setImmediate(function () {\n      cb(null, result);\n    });\n  }\n\n  if (result === -1) {\n    // end of stream\n    return cb(null, null);\n  }\n\n  if (result === 0) {\n    var self = this;\n    this.pq.once('readable', function () {\n      self.pq.stopReader();\n      self.pq.consumeInput();\n\n      self._consumeBuffer(cb);\n    });\n    return this.pq.startReader();\n  }\n\n  cb(new Error('Unrecognized read status: ' + result));\n};\n\nCopyStream.prototype._read = function (size) {\n  if (this._reading) return;\n  this._reading = true; // console.log('read begin');\n\n  var self = this;\n\n  this._consumeBuffer(function (err, buffer) {\n    self._reading = false;\n\n    if (err) {\n      return self.emit('error', err);\n    }\n\n    if (buffer === false) {\n      // nothing to read for now, return\n      return;\n    }\n\n    self.push(buffer);\n  });\n};\n\nvar consumeResults = function (pq, cb) {\n  var cleanup = function () {\n    pq.removeListener('readable', onReadable);\n    pq.stopReader();\n  };\n\n  var readError = function (message) {\n    cleanup();\n    return cb(new Error(message || pq.errorMessage()));\n  };\n\n  var onReadable = function () {\n    // read waiting data from the socket\n    // e.g. clear the pending 'select'\n    if (!pq.consumeInput()) {\n      return readError();\n    } // check if there is still outstanding data\n    // if so, wait for it all to come in\n\n\n    if (pq.isBusy()) {\n      return;\n    } // load our result object\n\n\n    pq.getResult(); // \"read until results return null\"\n    // or in our case ensure we only have one result\n\n    if (pq.getResult() && pq.resultStatus() !== 'PGRES_COPY_OUT') {\n      return readError('Only one result at a time is accepted');\n    }\n\n    if (pq.resultStatus() === 'PGRES_FATAL_ERROR') {\n      return readError();\n    }\n\n    cleanup();\n    return cb(null);\n  };\n\n  pq.on('readable', onReadable);\n  pq.startReader();\n};","map":null,"metadata":{},"sourceType":"script"}