{"ast":null,"code":"var assert = require('assert');\n\nvar Reader = module.exports = function (options) {\n  //TODO - remove for version 1.0\n  if (typeof options == 'number') {\n    options = {\n      headerSize: options\n    };\n  }\n\n  options = options || {};\n  this.offset = 0;\n  this.lastChunk = false;\n  this.chunk = null;\n  this.chunkLength = 0;\n  this.headerSize = options.headerSize || 0;\n  this.lengthPadding = options.lengthPadding || 0;\n  this.header = null;\n  assert(this.headerSize < 2, 'pre-length header of more than 1 byte length not currently supported');\n};\n\nReader.prototype.addChunk = function (chunk) {\n  if (!this.chunk || this.offset === this.chunkLength) {\n    this.chunk = chunk;\n    this.chunkLength = chunk.length;\n    this.offset = 0;\n    return;\n  }\n\n  var newChunkLength = chunk.length;\n  var newLength = this.chunkLength + newChunkLength;\n\n  if (newLength > this.chunk.length) {\n    var newBufferLength = this.chunk.length * 2;\n\n    while (newLength >= newBufferLength) {\n      newBufferLength *= 2;\n    }\n\n    var newBuffer = Buffer.alloc(newBufferLength);\n    this.chunk.copy(newBuffer);\n    this.chunk = newBuffer;\n  }\n\n  chunk.copy(this.chunk, this.chunkLength);\n  this.chunkLength = newLength;\n};\n\nReader.prototype.read = function () {\n  if (this.chunkLength < this.headerSize + 4 + this.offset) {\n    return false;\n  }\n\n  if (this.headerSize) {\n    this.header = this.chunk[this.offset];\n  } //read length of next item\n\n\n  var length = this.chunk.readUInt32BE(this.offset + this.headerSize) + this.lengthPadding; //next item spans more chunks than we have\n\n  var remaining = this.chunkLength - (this.offset + 4 + this.headerSize);\n\n  if (length > remaining) {\n    return false;\n  }\n\n  this.offset += this.headerSize + 4;\n  var result = this.chunk.slice(this.offset, this.offset + length);\n  this.offset += length;\n  return result;\n};","map":null,"metadata":{},"sourceType":"script"}