{"ast":null,"code":"//binary data writer tuned for creating\n//postgres message packets as effeciently as possible by reusing the\n//same buffer to avoid memcpy and limit memory allocations\nvar Writer = module.exports = function (size) {\n  this.size = size || 1024;\n  this.buffer = Buffer.alloc(this.size + 5);\n  this.offset = 5;\n  this.headerPosition = 0;\n}; //resizes internal buffer if not enough size left\n\n\nWriter.prototype._ensure = function (size) {\n  var remaining = this.buffer.length - this.offset;\n\n  if (remaining < size) {\n    var oldBuffer = this.buffer; // exponential growth factor of around ~ 1.5\n    // https://stackoverflow.com/questions/2269063/buffer-growth-strategy\n\n    var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;\n    this.buffer = Buffer.alloc(newSize);\n    oldBuffer.copy(this.buffer);\n  }\n};\n\nWriter.prototype.addInt32 = function (num) {\n  this._ensure(4);\n\n  this.buffer[this.offset++] = num >>> 24 & 0xFF;\n  this.buffer[this.offset++] = num >>> 16 & 0xFF;\n  this.buffer[this.offset++] = num >>> 8 & 0xFF;\n  this.buffer[this.offset++] = num >>> 0 & 0xFF;\n  return this;\n};\n\nWriter.prototype.addInt16 = function (num) {\n  this._ensure(2);\n\n  this.buffer[this.offset++] = num >>> 8 & 0xFF;\n  this.buffer[this.offset++] = num >>> 0 & 0xFF;\n  return this;\n}; //for versions of node requiring 'length' as 3rd argument to buffer.write\n\n\nvar writeString = function (buffer, string, offset, len) {\n  buffer.write(string, offset, len);\n}; //overwrite function for older versions of node\n\n\nif (Buffer.prototype.write.length === 3) {\n  writeString = function (buffer, string, offset, len) {\n    buffer.write(string, offset);\n  };\n}\n\nWriter.prototype.addCString = function (string) {\n  //just write a 0 for empty or null strings\n  if (!string) {\n    this._ensure(1);\n  } else {\n    var len = Buffer.byteLength(string);\n\n    this._ensure(len + 1); //+1 for null terminator\n\n\n    writeString(this.buffer, string, this.offset, len);\n    this.offset += len;\n  }\n\n  this.buffer[this.offset++] = 0; // null terminator\n\n  return this;\n};\n\nWriter.prototype.addChar = function (c) {\n  this._ensure(1);\n\n  writeString(this.buffer, c, this.offset, 1);\n  this.offset++;\n  return this;\n};\n\nWriter.prototype.addString = function (string) {\n  string = string || \"\";\n  var len = Buffer.byteLength(string);\n\n  this._ensure(len);\n\n  this.buffer.write(string, this.offset);\n  this.offset += len;\n  return this;\n};\n\nWriter.prototype.getByteLength = function () {\n  return this.offset - 5;\n};\n\nWriter.prototype.add = function (otherBuffer) {\n  this._ensure(otherBuffer.length);\n\n  otherBuffer.copy(this.buffer, this.offset);\n  this.offset += otherBuffer.length;\n  return this;\n};\n\nWriter.prototype.clear = function () {\n  this.offset = 5;\n  this.headerPosition = 0;\n  this.lastEnd = 0;\n}; //appends a header block to all the written data since the last\n//subsequent header or to the beginning if there is only one data block\n\n\nWriter.prototype.addHeader = function (code, last) {\n  var origOffset = this.offset;\n  this.offset = this.headerPosition;\n  this.buffer[this.offset++] = code; //length is everything in this packet minus the code\n\n  this.addInt32(origOffset - (this.headerPosition + 1)); //set next header position\n\n  this.headerPosition = origOffset; //make space for next header\n\n  this.offset = origOffset;\n\n  if (!last) {\n    this._ensure(5);\n\n    this.offset += 5;\n  }\n};\n\nWriter.prototype.join = function (code) {\n  if (code) {\n    this.addHeader(code, true);\n  }\n\n  return this.buffer.slice(code ? 0 : 5, this.offset);\n};\n\nWriter.prototype.flush = function (code) {\n  var result = this.join(code);\n  this.clear();\n  return result;\n};","map":null,"metadata":{},"sourceType":"script"}